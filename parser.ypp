%{
/* Definitions section */
#include "hw3_output.hpp"
#include "source.hpp"
extern int yylineno;
int yylex();
void yyerror(const char*);

%}
/* Declarations */

/* Regular tokens */
%token ID
%token NUM
%token STRING

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token CONST
%token TRUE
%token FALSE
%token RETURN

%nonassoc IF
%nonassoc ELSE

%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA

%right ASSIGN

%left OR

%left AND

%left EQUALITY

%nonassoc RELATIONAL

%left ADDSUB_BINOP

%left MULDIV_BINOP

%right CASTING

%right NOT


%left LPAREN
%left RPAREN

%token LBRACE
%token RBRACE



%%
/* Rules */
Program: M_Init Funcs
{
  try {
      SymbolsRepo::Instance().findSymbol("main");
  }
  catch(SymbolNotFound& e) {
    output::errorMainMissing();
    exit(0);
  }
  SymbolsRepo::Instance().closeScope();
} ;

/* ******************************************************************************************** */

M_Init: /*epsilon*/
{
  SymbolsRepo::Instance().Initialize();
} ;
/* ******************************************************************************************** */

Funcs: /*epsilon*/
{  } ;
/* ******************************************************************************************** */

Funcs: FuncDecl Funcs
 {  } ;
 /* ******************************************************************************************** */
FuncDecl: RetType ID LPAREN Formals RPAREN
                                            {
                                              try {
                                                SymbolsRepo::Instance().insertSymbol((IdNode*)$2.name, Type((RetTypeNode*)$1.type, (FormalsNode*)$4.arguments));
                                              }
                                              catch (SymbolAlreadyDefinedInScope& e) {
                                                 errorDef($2.lineno, (IdNode*)$2.name);
                                                 exit(0);
                                              }
                                              SymbolsRepo::Instance().openNewScope();
                                              for(auto& arg : (FormalsNode*)$4.arguments) {
                                                SymbolsRepo::Instance().insertSymbolAsArgument(arg.name, arg);
                                              }
                                            }

 LBRACE Statements RBRACE
 {
    SymbolsRepo::Instance().closeScope();
 } ;

/* ******************************************************************************************** */
RetType: Type
 {
    $$ = new Type((TypeNode)$1.type);
 };
/* ******************************************************************************************** */
RetType:  VOID
{
    $$ = new Type(VOID_TYPE);
 } ;
/* ******************************************************************************************** */
Formals: /*epsilon*/
{
  $$ = new FormalsNode();
 } ;
/* ******************************************************************************************** */
Formals: FormalsList
{
  $$ = new FormalsNode($1.lineno, (FormalsListNode*)$1.args);
 } ;
/* ******************************************************************************************** */
FormalsList: FormalDecl
{
    $$ = new FormalsListNode($1.lineno,  {(FormalDeclNode*)$1.arg} );
 } ;
/* ******************************************************************************************** */
FormalsList: FormalDecl COMMA FormalsList
{
    $$ = $3;
    $$.addArgument($1.lineno, (FormalDeclNode*)$1.arg);
 } ;
/* ******************************************************************************************** */
FormalDecl: TypeAnnotation Type ID
{
    $$ = new FormalDeclNode($1.lineno, (TypeAnnotationNode*)$1.is_const, (TypeNode*)$2.type, (IdNode*)$3.name );
} ;
/* ******************************************************************************************** */
Statements: Statement
{
} ;
/* ******************************************************************************************** */
Statements: Statements Statement
{
} ;
/* ******************************************************************************************** */
Statement: { SymbolsRepo::Instance().openNewScope(); } LBRACE Statements RBRACE
 {
   SymbolsRepo::Instance().closeScope();
 } ;
/* ******************************************************************************************** */
Statement: TypeAnnotation Type ID SC
{
    if((TypeAnnotationNode*)$1.is_const) { /* TODO $1 or $4? */
      errorConstDef($1.lineno);
      exit(0);
    }
    try {
      SymbolsRepo::Instance().insertSymbol((IdNode*)$3.name, Type(false, (TypeNode*)$2.type));
    }
    catch (SymbolAlreadyDefinedInScope& e) {
        errorDef($3.lineno, (IdNode*)$3.name);
        exit(0);
    }
};
/* ******************************************************************************************** */
Statement: TypeAnnotation Type ID ASSIGN Exp SC
{
} ;
/* ******************************************************************************************** */
Statement: ID ASSIGN Exp SC                                             {  } ;
Statement: Call SC                                                      {  } ;
Statement: RETURN SC                                                    {  } ;
Statement: RETURN Exp SC                                                {  } ;
Statement: IF LPAREN Exp RPAREN Statement %prec IF                      {  } ;
Statement: IF LPAREN Exp RPAREN Statement ELSE Statement                {  } ;
Statement: WHILE LPAREN Exp RPAREN Statement                            {  } ;
Statement: BREAK SC                                                     {  } ;
Statement: CONTINUE SC                                                  {  } ;
Call: ID LPAREN ExpList RPAREN                                          {  } ;
Call: ID LPAREN RPAREN                                                  {  } ;
ExpList: Exp                                                            {  } ;
ExpList: Exp COMMA ExpList                                              {  } ;
Type: INT                                                               {  } ;
Type: BYTE                                                              {  } ;
Type: BOOL                                                              {  } ;
TypeAnnotation: /*epsilon*/
{
   $$ = new TypeAnnotationNode(false);
} ;
TypeAnnotation: CONST
{
  $$ = new TypeAnnotationNode(true, $1.lineno);
} ;
Exp: LPAREN Exp RPAREN                                                  {  } ;
Exp: Exp MULDIV_BINOP Exp                                               {  } ;
Exp: Exp ADDSUB_BINOP Exp                                               {  } ;
Exp: ID                                                                 {  } ;
Exp: Call                                                               {  } ;
Exp: NUM                                                                {  } ;
Exp: NUM B                                                              {  } ;
Exp: STRING                                                             {  } ;
Exp: TRUE                                                               {  } ;
Exp: FALSE                                                              {  } ;
Exp: NOT Exp                                                            {  } ;
Exp: Exp AND Exp                                                        {  } ;
Exp: Exp OR Exp                                                         {  } ;
Exp: Exp RELATIONAL Exp                                                 {  } ;
Exp: Exp EQUALITY Exp                                                   {  } ;
Exp: LPAREN Type RPAREN Exp %prec CASTING                               {  } ;
%%

/* C user routines */
int main() {
    return yyparse();
}
void yyerror(char const* msg) {
    output::errorSyn(((Node*) yylval)->lineno);
    exit(0);
}
