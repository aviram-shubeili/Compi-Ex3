%{
/* Definitions section */
#include "hw3_output.hpp"
#include "source.hpp"
extern int yylineno;
int yylex();
void yyerror(const char*);

%}
/* Declarations */

/* Regular tokens */
%token ID
%token NUM
%token STRING

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token CONST
%token TRUE
%token FALSE
%token RETURN

%nonassoc IF
%nonassoc ELSE

%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA

%right ASSIGN

%left OR

%left AND

%left EQUALITY

%nonassoc RELATIONAL

%left ADDSUB_BINOP

%left MULDIV_BINOP

%right CASTING

%right NOT


%left LPAREN
%left RPAREN

%token LBRACE
%token RBRACE



%%
/* Rules */
Program: M_Init Funcs                                                   {  } ;
M_Init: /*epsilon*/                                                     { SymbolsRepo::Instance().Initialize(); } ;
Funcs: /*epsilon*/                                                      {  } ;
Funcs: FuncDecl Funcs                                                   {  } ;
FuncDecl: RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE     {  } ;
RetType: Type                                                           {  } ;
RetType:  VOID                                                          {  } ;
Formals: /*epsilon*/                                                    {  } ;
Formals: FormalsList                                                    {  } ;
FormalsList: FormalDecl                                                 {  } ;
FormalsList: FormalDecl COMMA FormalsList                               {  } ;
FormalDecl: TypeAnnotation Type ID                                      {  } ;
Statements: Statement                                                   {  } ;
Statements: Statements Statement                                        {  } ;
Statement: LBRACE Statements RBRACE                                     {  } ;
Statement: TypeAnnotation Type ID SC                                    {  } ;
Statement: TypeAnnotation Type ID ASSIGN Exp SC                         {  } ;
Statement: ID ASSIGN Exp SC                                             {  } ;
Statement: Call SC                                                      {  } ;
Statement: RETURN SC                                                    {  } ;
Statement: RETURN Exp SC                                                {  } ;
Statement: IF LPAREN Exp RPAREN Statement %prec IF                      {  } ;
Statement: IF LPAREN Exp RPAREN Statement ELSE Statement                {  } ;
Statement: WHILE LPAREN Exp RPAREN Statement                            {  } ;
Statement: BREAK SC                                                     {  } ;
Statement: CONTINUE SC                                                  {  } ;
Call: ID LPAREN ExpList RPAREN                                          {  } ;
Call: ID LPAREN RPAREN                                                  {  } ;
ExpList: Exp                                                            {  } ;
ExpList: Exp COMMA ExpList                                              {  } ;
Type: INT                                                               {  } ;
Type: BYTE                                                              {  } ;
Type: BOOL                                                              {  } ;
TypeAnnotation: /*epsilon*/                                             {  } ;
TypeAnnotation: CONST                                                   {  } ;
Exp: LPAREN Exp RPAREN                                                  {  } ;
Exp: Exp MULDIV_BINOP Exp                                               {  } ;
Exp: Exp ADDSUB_BINOP Exp                                               {  } ;
Exp: ID                                                                 {  } ;
Exp: Call                                                               {  } ;
Exp: NUM                                                                {  } ;
Exp: NUM B                                                              {  } ;
Exp: STRING                                                             {  } ;
Exp: TRUE                                                               {  } ;
Exp: FALSE                                                              {  } ;
Exp: NOT Exp                                                            {  } ;
Exp: Exp AND Exp                                                        {  } ;
Exp: Exp OR Exp                                                         {  } ;
Exp: Exp RELATIONAL Exp                                                 {  } ;
Exp: Exp EQUALITY Exp                                                   {  } ;
Exp: LPAREN Type RPAREN Exp %prec CASTING                               {  } ;
%%

/* C user routines */
int main() {
    return yyparse();
}
void yyerror(char const* msg) {
    output::errorSyn(((Node*) yylval)->lineno);
    exit(0);
}
